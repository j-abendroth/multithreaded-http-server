###### John Abendroth
###### CruzID: jabendro
# HTTP Server Design Document

## Introduction
The program `httpserver` is designed to act as a multithreaded http server for clients.

## Design
### Multithreading
My multithreading design was based off a queue. It starts with an array of worker threads, where for n threads there are n workers. The server starts with opening the function `worker_thread_func()` that is passed to all the worker threads when they're created. The worker threads start by taking the lock and checking the queue, so that if the queue isn't empty they can start dequeueing file descriptors right away. They then check their queue to see if there is a client connection file descriptor ready for processing. If there is not, `pthread_cond_wait()` is called and the thread sleeps until signaled to wake up. The worker threads are signaled to wake up by the main function that runs in an infinite loop, waiting for clients to be accepted by the `accept()` call. There, once a new client is accepted their connection file descriptor is placed in a specific worker thread's queue. Which thread gets that file descriptor placed in their queue is determined by a counter which calculates the modulus of how many loops have been run by the number of threads (`target_thread = count % nthreads;`). This was done to prevent any "thundering herd" possibility of tons of threads waking up and trying to access the same queue. Once enqueued, the main signals that specific worker thread to wake up, and the main function returns to listening for connections. I chose this queue instead of letting `accept()` run a backlog queue just because it seemed like a more sure thing to me. I was able to implement a link-based queue, so that there is no number of connections it holds, instead of having `accept()` only hold 5 connections or so. Once the worker thread wakes up and determines the queue is not empty anymore, it takes the lock back and dequeues a connection. That file descriptor is then sent for processing the same way Assignment 1 did. At the end of processing the request, the worker thread checks if logging is enabled. If it is, the worker thread takes the lock for the logging queue and attempts to enqueue two things: a temp file file descriptor which contains the top of the logging information that won't be hex dumped, and a another temp file file descriptor that contains the contents of a PUT/GET request. It only enqueues the second file if the designated file descriptor for it in the worker object is not -1, because it's set to -1 at default and isn't changed for HEAD requests. Then the worker thread is done, and closes the client socket and restarts the process by attempted to get a new connection file descriptor and waiting if there are none ready.

### Logging

My Logging functionality works similar to my multithreading. There is a distinct difference though, where I only used 1 shared logging struct reference across the whole program since there is only 1 logging thread. I used a queue for the logging thread, where once a worker thread finishes their processing for a specific client file descriptor, it enqueues 2 file descriptors as previously discussed. The logging works by first writing the temp file of the top of the log request, since it will always be defined and describing what the request to the server was. Then it checks if the second file is defined, and if it is, it loops through for the length of the file converting each byte to hex and writing it to the log file. Specifically, I kept track of where I was in the log file by using a variable `totalwr` that updated every time a `pwrite()` was called, with the value of the write size from that `pwrite()`. For exact formatting, I first checked if the bytes logged is greater than 0 and if its modulus of 20 is equal to 0. If it is, I write a new line. Then if the bytes logged mod 20 is zero, I pad with the number of bytes written to 8 digits. Then finally, I convert the current byte[i] in the loop to hex and write it to the log file. After exiting, I check if the total bytes read equals the length of the request, because then I know it's the end of the file and it needs one final new line character before the termination signal. The logging thread maintains synchronization the same way the worker threads do, where the logging thread checks if its queue is empty, and if the queue is empty it waits with `pthread_cond_wait`.

### Interaction
Most interaction in the server was done by pushing to queues on individual worker threads, so that I could then access that worker thread object anywhere else in the program and not have to worry about synchronization since only that thread had access to it. This is the main reason I chose an array of worker threads, to alleviate most concerns with synchronization. The only places I had to use mutexes to ensure synchronization was Enqueueing/Dequeueing from the worker threads, the logging threads, and when updating the variable tracking how many errors there are in the current session for healthcheck.
